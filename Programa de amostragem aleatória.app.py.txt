import streamlit as st
import pandas as pd
import geopandas as gpd
import numpy as np
from shapely.geometry import Point
import fiona
import random
import io

# Configura√ß√µes iniciais
fiona.drvsupport.supported_drivers['KML'] = 'rw'

st.set_page_config(page_title="Auditoria de Obras", layout="wide")

st.title("üöß Auditoria Rodovi√°ria: Amostragem Aleat√≥ria")
st.markdown("Selecione o arquivo KML e defina os par√¢metros para gerar os pontos de extra√ß√£o.")

# --- BARRA LATERAL ---
st.sidebar.header("Configura√ß√µes de Campo")
uploaded_file = st.sidebar.file_uploader("Upload do KML da Rodovia", type=['kml'])
largura = st.sidebar.number_input("Largura da pista (m)", value=7.0, step=0.5)
area_min = st.sidebar.number_input("√Årea m√≠nima por amostra (m¬≤)", value=3000.0, step=100.0)
qtd_desejada = st.sidebar.number_input("Quantidade m√≠nima de amostras", value=5, step=1)
dist_min_entre_pontos = st.sidebar.number_input("Dist√¢ncia m√≠nima entre amostras (m)", value=150.0)
recuo_curva = 130.0

# --- FUN√á√ïES DE APOIO ---
def identificar_zonas_curvas(linha, recuo):
    zonas = []
    passo = 10
    for d in range(passo, int(linha.length) - passo, passo):
        p1, p2, p3 = linha.interpolate(d-passo), linha.interpolate(d), linha.interpolate(d+passo)
        v1 = np.array([p2.x-p1.x, p2.y-p1.y])
        v2 = np.array([p3.x-p2.x, p3.y-p2.y])
        norm = (np.linalg.norm(v1) * np.linalg.norm(v2))
        if norm != 0 and (np.dot(v1, v2)/norm) < 0.9995:
            zonas.append((d - recuo, d + recuo))
    return zonas

# --- PROCESSAMENTO ---
if uploaded_file:
    # Leitura do arquivo
    gdf = gpd.read_file(uploaded_file, driver='KML')
    utm_gdf = gdf.to_crs(gdf.estimate_utm_crs())
    linha_rodovia = utm_gdf.geometry.iloc[0]
    extensao = linha_rodovia.length
    
    # Memorial de C√°lculo
    area_total = extensao * largura
    n_minimo = int(np.ceil(area_total / area_min))
    n_final = max(qtd_desejada, n_minimo)
    
    st.info(f"**Memorial de C√°lculo:** Extens√£o de {extensao:.2f}m | √Årea Total: {area_total:.2f}m¬≤ | M√≠nimo Normativo: {n_minimo} amostras.")

    if st.button("Gerar Amostras Seguras"):
        zonas_proibidas = identificar_zonas_curvas(linha_rodovia, recuo_curva)
        amostras_temp = []
        tentativas = 0
        
        with st.spinner('Calculando pontos em trechos de reta...'):
            while len(amostras_temp) < n_final and tentativas < 20000:
                dist = random.uniform(0, extensao)
                esta_proibido = any(i <= dist <= f for i, f in zonas_proibidas)
                
                if not esta_proibido:
                    offset = random.uniform(-(largura/2), (largura/2))
                    p1, p2 = linha_rodovia.interpolate(dist), linha_rodovia.interpolate(dist + 0.5)
                    dx, dy = p2.x - p1.x, p2.y - p1.y
                    mag = np.sqrt(dx**2 + dy**2)
                    ponto = Point(p1.x - dy/mag * offset, p1.y + dx/mag * offset)
                    
                    if all(ponto.distance(prev['geom']) >= dist_min_entre_pontos for prev in amostras_temp):
                        amostras_temp.append({'geom': ponto, 'dist': dist})
                tentativas += 1

        # Ordena√ß√£o e Finaliza√ß√£o
        amostras_temp.sort(key=lambda x: x['dist'])
        
        # Criar GeoDataFrame
        final_gdf = gpd.GeoDataFrame({
            'Name': [f"Amostra {i+1:02d} (km {a['dist']/1000:.3f})" for i, a in enumerate(amostras_temp)],
            'KM': [a['dist'] for a in amostras_temp]
        }, geometry=[a['geom'] for a in amostras_temp], crs=utm_gdf.crs).to_crs(epsg=4326)

        # Download
        buffer = io.BytesIO()
        final_gdf.to_file(buffer, driver='KML')
        st.success(f"Foram geradas {len(amostras_temp)} amostras sequenciais!")
        st.download_button(label="üì• Baixar KML das Amostras", data=buffer.getvalue(), file_name="amostras_auditoria.kml", mime="application/vnd.google-earth.kml+xml")
        
        # Mostrar tabela
        st.table(pd.DataFrame({
            'Identifica√ß√£o': [f"Amostra {i+1:02d}" for i in range(len(amostras_temp))],
            'KM (m)': [f"{a['dist']:.2f}" for a in amostras_temp]
        }))